---
title: "project-arima"
author: "rst"
date: "2024-06-02"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Data Preparation


```{r}
library(forecast)
library(data.table)
library(lubridate)
library(dplyr)
library(tidyr)
library(GGally)
library(matrixStats)
library(zoo)
library(readxl)
library(openxlsx)
library(writexl)

tday=today("Turkey")

day_before_tday <- tday - 1

file_weather = paste0("/Users/serratopaloglu/Desktop/daily/may25_w.csv")
file_production = paste0("/Users/serratopaloglu/Desktop/daily/may25.csv")

weather_data = fread(file_weather)
production_data = fread(file_production)

# getting full weather date and hours as a template
template_dt = unique(weather_data[,list(date,hour)])
template_dt = merge(template_dt,production_data,by=c('date','hour'),all.x=T)
template_dt = template_dt[date<=(tday + 1)]
#template_dt = template_dt[date<=(tday)]


###NA VALUES###
any_na <- anyNA(weather_data)
if (any_na) {
  cat("The dataset contains NA values.\n")
  # Display the count of NAs per column
  print(colSums(is.na(weather_data)))
} else {
  cat("The dataset does not contain any NA values.\n")
}
# Display all rows that have NA values
na_rows <- weather_data[!complete.cases(weather_data), ]
#View(na_rows)

# Fill NA values with the average of the surrounding values (linear interpolation)
merged_data_filled <- weather_data %>%
  mutate(across(where(is.numeric), ~ na.approx(.x, na.rm = FALSE)))

# Fill leading NAs with the next available value, upward
merged_data_filled <- merged_data_filled %>%
  mutate(across(where(is.numeric), ~ na.locf(.x, fromLast = TRUE, na.rm = FALSE)))

weather_data<- merged_data_filled
#####


#Coordinate aggregation by long to wide format
long_weather <- weather_data
long_weather <- melt(weather_data,id.vars=c(1:4))
hourly_region_averages = dcast(long_weather, date+hour~variable,fun.aggregate=mean)
#View(hourly_region_averages)

# Merge with hourly_region_averages
template_dt_with_weather <- merge(template_dt, hourly_region_averages, by = c('date', 'hour'), all.x = TRUE)
#View(template_dt_with_weather)
#Order it by date and hour
template_dt_with_weather = template_dt_with_weather[order(date,hour)]
template_dt_with_aggregate <- template_dt_with_weather

template_dt_with_aggregate$hourly_cloud_average <- rowMeans(dplyr::select(template_dt_with_aggregate, starts_with("tcdc_")), na.rm = TRUE)
template_dt_with_aggregate$hourly_max_t <- rowMaxs(as.matrix(dplyr::select(template_dt_with_aggregate, starts_with("tmp_"))), na.rm = TRUE)
# Identify columns with 'tmp_' prefix
tmp_columns <- grep("^tmp_", names(template_dt_with_aggregate))

# Extract the subset of columns
tmp_data <- template_dt_with_aggregate[, ..tmp_columns]

# Convert data frame to matrix
tmp_matrix <- as.matrix(tmp_data)

# Calculate row maximums
template_dt_with_aggregate$hourly_max_t <- rowMaxs(tmp_matrix, na.rm = TRUE)

#View(template_dt_with_aggregate)


# Use select to exclude coumns starting with "tcdc_" to focus on average
template_dt_with_aggregate <- template_dt_with_aggregate %>%
  dplyr::select(-starts_with("tcdc_"))
#-starts_with("tmp_"))

# Read your holiday dataset


holiday_data <- read_excel("/Users/serratopaloglu/Desktop/daily/Short Holiday12.xlsx")
# Convert date column to Date format
holiday_data$date <- as.Date(holiday_data$date, format = "%d.%m.%Y", na.rm = TRUE)

# Merge holiday data with production dataset based on the date column
all_data <- merge(template_dt_with_aggregate, holiday_data, by = "date", all.x = TRUE)


```

## ARIMA model

ARIMA models ( Autoregressive Integrated Moving Average models) are widely used for predicting future trends. These models use lagged moving averages to smooth the given time series data input and assume that the future will be similar to past trends. This assumption creates a weakness for ARIMA models such that the model cannot predict rapid shock conditions. In this project, the input time series is aggregated hourly sun energy production levels throughout 25 different locations. The assumption during prediction phase was that on day d, the predictions were needed for day d+1 and the production values until the end of day d-1 was known. Additionally, since it was known in the given data set that the sun energy production levels for hours 0,1,2,3,19,20,21,22,23 were 0 for all days, ARIMA model was used to predict hours starting with 4 up to 18. The first step was to use an ARIMA model for overall data, without separating it into hourly data sets.

```{r}
#Defining today and the day before today.
tday=today("Turkey")-9 #Adjust for the appropriate date if needed, we are extracting 9 here to get a feasible output since today is June 2 and the file we are using has production values up to May 24, so the predictions will be made for May 26 as if we are in May 25.
day_before_tday <- tday - 1


#Creating the data set that will be used for ARIMA forecasting. to_be_forecasted data set is for extracting the days that will be forecasted. 
all_data = all_data[!is.na(production)]

available_data = all_data[!is.na(production) & hour >= 4 & hour <= 18,]
to_be_forecasted = template_dt_with_weather[is.na(production) & hour >= 4 & hour <= 18, ]

#Constructing an overall ARIMA model for the available_data.
fitted <- auto.arima(available_data$production, trace=TRUE)

# Forecasting
forecast_horizon <- nrow(to_be_forecasted)
forecasted_arima <- forecast(fitted, h = forecast_horizon)$mean

# Setting negative forecasts to zero
forecasted_arima[forecasted_arima < 0] <- 0

# Storing forecasts in a table
forecast_table <- data.frame(date = to_be_forecasted$date, 
                             hour = to_be_forecasted$hour, 
                             arima_forecast = forecasted_arima)

# Ordering the forecast table by date and hour
forecast_table <- forecast_table[order(forecast_table$date, forecast_table$hour), ]

# Tomorrow's hourly predictions
day_ahead_forecast <- forecast_table[forecast_table$date == (tday + 1), ]

print(day_ahead_forecast)


```


## Forecasting for Hours Individually Option

However, fitting one ARIMA model to every hour ended up performing poorly for predicting hours individually since each hour's trend was different. To resolve this, individual ARIMA models were fitted to hourly data sets. In the below code, a for loop is used to iterate through hours between 4 and 18 to fit an ARIMA model. 
```{r}
forecast_results <- list()

for (i in 4:18) {
  # Isolating the data for the current hour
  hour_data <- available_data[available_data$hour == i, ]
  # Fiting an ARIMA model to the hour-specific data
  fitted <- auto.arima(hour_data$production, trace = TRUE)
  # Determining the number of forecasts needed for the current hour
  forecast_horizon <- nrow(to_be_forecasted[to_be_forecasted$hour == i, ])
  # Forecasting production using the hour-specific ARIMA model
  forecasted_arima <- forecast(fitted, h = forecast_horizon)$mean
  # Ensuring no negative forecasts
  forecasted_arima[forecasted_arima < 0] <- 0
  # Creating a data frame for the forecast results for the current hour
  forecast_table_hour <- data.frame(
    date = to_be_forecasted[to_be_forecasted$hour == i, ]$date,
    hour = to_be_forecasted[to_be_forecasted$hour == i, ]$hour,
    arima_forecast = forecasted_arima
  )
  # Add the forecast results to the list
  forecast_results[[as.character(i)]] <- forecast_table_hour
}

forecast_results_df <- lapply(forecast_results, as.data.frame)

# Combine all forecast results into a single data frame
combined_forecasts <- bind_rows(forecast_results_df)

# Arrange the combined forecasts
combined_forecasts_sorted <- combined_forecasts %>%
  arrange(date, hour)

# Apply formatting function to all numeric columns to remove scientific notation
combined_forecasts_sorted <- combined_forecasts_sorted %>%
  mutate(across(where(is.numeric), ~ format(.x, scientific = FALSE)))

combined_forecasts_sorted

```
##Â ARIMA MODELS COMPARISON 
To evaluate which ARIMA model would be the better model to use, a data set between February 1 2024 and May 15 2024 was used to evaluate metrics for overall ARIMA model and hour-specific ARIMA model. Below code calculates forecasts for using overall ARIMA model which means fitting ONE Arima model for all hours.

The code below shows our overall ARIMA Model's predictions for the phase between February 1 2024 and May 15 2024. The results showed that the overall ARIMA model lacked precision especially in the hours at the edges of our interval such as hour 4,5 and 17,18. These hours were predicted around 2 and 3 that are values greater than the actual values that were always between 0 and 1 in the historical data. 



```{r}
library(forecast)
library(data.table)

# Ensuring the data is in data.table format for easier handling
all_data <- as.data.table(all_data)
template_dt_with_weather <- as.data.table(template_dt_with_weather)

# Define the date range for forecasting
start_date <- as.Date("2024-02-01")
end_date <- as.Date("2024-05-15")

# Filter available data within the specified hours and date range, removing NA values
available_data <- all_data[!is.na(production) & hour >= 4 & hour <= 18 & date < start_date]

# Filter data to be forecasted within the specified hours and date range
to_be_forecasted <- template_dt_with_weather[!is.na(production) & hour >= 4 & hour <= 18 & date >= start_date & date <= end_date]

# Constructing an overall ARIMA model for the available data
fitted <- auto.arima(available_data$production, trace = TRUE)

# Forecasting for the specified horizon
forecast_horizon <- nrow(to_be_forecasted)
forecasted_arima <- forecast(fitted, h = forecast_horizon)$mean

# Setting negative forecasts to zero
forecasted_arima[forecasted_arima < 0] <- 0

# Storing forecasts in a table
forecast_table <- data.table(date = to_be_forecasted$date, 
                             hour = to_be_forecasted$hour, 
                             arima_forecast = forecasted_arima)

# Ordering the forecast table by date and hour
setorder(forecast_table, date, hour)

# Printing the forecasts for the specified date range
print(forecast_table)
```




## Evaluating overall ARIMA Model with calculating MAE value.

```{r}
in_sample_forecasts <- forecast_table$arima_forecast
data_overall <- to_be_forecasted$production - in_sample_forecasts
mean(abs(data_overall))

```
## Evaluating hour-specific ARIMA Model.



The code below shows our chosen hour-specific ARIMA Model's predictions for the phase between February 1 2024 and May 15 2024. 
```{r}
start_date <- as.Date("2024-02-01")
end_date <- as.Date("2024-05-15")

#Creating the data set that will be used for ARIMA forecasting. to_be_forecasted data set is for extracting the days that will be forecasted. The data is separated for the days that will be predicted up to Feb 1 to May 15. Since the data we were given had the actual production values between February 1 2024 and May 15 2024, available_data and  to_be_forecasted data set were created in a way such that available_data only included the data before February 1 2024 and to_be_forecasted data had the data between February 1 2024 and May 15 2024.

all_data = all_data[!is.na(production)]
available_data <- all_data[!is.na(production) & hour >= 4 & hour <= 18 & date < start_date,]
to_be_forecasted <- template_dt_with_weather[!is.na(production) & hour >= 4 & hour <= 18 & date >= start_date & date <= end_date, ]

# Same forecasting approach was used for these dates as well. A for loop is used to iterate through each day.

# Initialize an empty list to store forecast results
forecast_results <- list()

# Iterate over the list of hours
for (i in 4:18) {
  # Isolate the data for the current hour
  hour_data <- available_data[available_data$hour == i, ]
  # Fit an ARIMA model to the hour-specific data
  fitted <- auto.arima(hour_data$production, trace = TRUE)
  # Determine the number of forecasts needed for the current hour
  forecast_horizon <- nrow(to_be_forecasted[to_be_forecasted$hour == i, ])
  # Forecast production using the hour-specific ARIMA model
  forecasted_arima <- forecast(fitted, h = forecast_horizon)$mean
  # Ensure no negative forecasts
  forecasted_arima[forecasted_arima < 0] <- 0
  # Create a data frame for the forecast results for the current hour
  forecast_table_hour <- data.frame(
    date = to_be_forecasted[to_be_forecasted$hour == i, ]$date,
    hour = to_be_forecasted[to_be_forecasted$hour == i, ]$hour,
    arima_forecast = forecasted_arima
  )
  # Add the forecast results to the list
  forecast_results[[as.character(i)]] <- forecast_table_hour
}

# Combine all the forecast results into a single data frame
forecast_results_df <- lapply(forecast_results, as.data.frame)

# Combine all forecast results into a single data frame
combined_forecasts <- bind_rows(forecast_results_df)

# Arrange the combined forecasts
combined_forecasts_sorted <- combined_forecasts %>%
  arrange(date, hour)

# Apply formatting function to all numeric columns to remove scientific notation
combined_forecasts_sorted <- combined_forecasts_sorted %>%
  mutate(across(where(is.numeric), ~ format(.x, scientific = FALSE)))

combined_forecasts_sorted

# Write the sorted forecast results to an Excel file if one wants to analyze.
write.xlsx(combined_forecasts_sorted, "forecasts_sorted.xlsx", 
           asTable = TRUE, showNA = FALSE, digits = 10)


pro_data <- all_data %>% 
  filter(date >= start_date & date <= end_date, hour >= 4 & hour <= 18) %>%
  select(date, hour, production)
combined_data$hour <- as.integer(combined_data$hour)
pro_data$hour <- as.integer(pro_data$hour)
combined_forecasts_sorted$hour <- as.integer(combined_forecasts_sorted$hour)
combined_data <- merge(pro_data, combined_forecasts_sorted, by = c("date", "hour"), all.x = TRUE)
combined_data$production <- as.numeric(combined_data$production)
combined_data$arima_forecast <- as.numeric(combined_data$arima_forecast)
combined_data$arima_forecast <- round(combined_data$arima_forecast, digits = 6) 

write.xlsx(combined_data, "project_values.xlsx", 
           asTable = TRUE, showNA = FALSE, digits = 10)

```
## EVALUATING ARIMA MODEL'S PERFORMANCE WITH METRICS 

The code below calculates the mean absolute error for our forecasts (MAE). 
```{r}
## CALCULATING THE MEAN ABSOLUTE ERROR 
mean(abs(combined_data$production-combined_data$arima_forecast))
```

Since the MAE value for hour-specific ARIMA model which is 1.997853 was lesser than MAE value of overall ARIMA model which is 3.271202,  hour-specific ARIMA models were chosen for forecasting. 

